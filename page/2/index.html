<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Gloria"><meta name="copyright" content="Gloria"><title>Stay hungry | Gloria's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Gloria</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Gloria's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/aboat">Aboat</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Gloria's Blog</div><div id="site-sub-title">Stay hungry</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/10/03/CSS%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C%E6%A5%BC/">CSS基础-实验楼</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/CSS/">CSS</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/">实验楼</a></span><div class="content"><h4 id="高级框操作"><a href="#高级框操作" class="headerlink" title="高级框操作"></a>高级框操作</h4><p>当你使用绝对的值设置了一个框的大小（如，固定像素的宽/高），允许的大小可能不适合放置内容，这种情况下内容会从盒子溢流。我们使用 overflow 属性来控制这种情况的发生。常用的值：</p>
<ul>
<li>auto:当内容过多的时候溢流的内容被隐藏，然后出现滚动条，让我们滚动查看所有的内容。</li>
<li>hidden: 当内容过多，溢流的内容被隐藏。</li>
<li>visible: 当内容过多，溢流的内容被显示在盒子的外边。</li>
</ul>
<h4 id="CSS-框类型"><a href="#CSS-框类型" class="headerlink" title="CSS 框类型"></a>CSS 框类型</h4><p>display 属性有很多的属性值。这里着重讲三个常见的 :block, inline, 和 inline-block。</p>
<ul>
<li>块级元素的特点：<ol>
<li>一个块级元素独占一行。</li>
<li>元素的高度、宽度、行高以及顶和底边距都可设置。</li>
<li>元素宽度在不设置的情况下，是它本身父容器的 100%（和父元素的宽度一致），除非设定一个宽度。</li>
<li>常见的块级元素：div、p、h1、form、ul和 li。</li>
</ol>
</li>
<li>行内元素的特点：<ol>
<li>和其他元素都在一行上。</li>
<li>元素的高度、宽度、行高及顶部和底部边距不可设置。</li>
<li>元素的宽度就是它包含的文字或图片的宽度，不可改变。</li>
<li>常见的行内元素：a、span、br、i、em&gt;、strong、label。</li>
</ol>
</li>
<li>行内块元素特点：同时具备内联元素、块状元素的特点。常见行内块元素：img、input。</li>
</ul>
<h4 id="Web-字体"><a href="#Web-字体" class="headerlink" title="Web 字体"></a>Web 字体</h4><p>首先我们通过 @font-face 指定要下载的字体文件。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">      <span class="attribute">font-family</span>: <span class="string">&quot;Bitstream Vera Serif Bold&quot;</span>;</span><br><span class="line">      <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后使用 @font-face 中指定的字体种类名称来将你的定制字体应用到你需要的地方，比如说：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: <span class="string">&quot;Bitstream Vera Serif Bold&quot;</span>, serif &#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h4><p> flex 模型： <img src="https://mdn.mozillademos.org/files/3739/flex_terms.png/vm" alt="img"></p>
<h5 id="容器的属性："><a href="#容器的属性：" class="headerlink" title="容器的属性："></a>容器的属性：</h5><ul>
<li>flex-direction 属性：设置主轴的方向（也就是项目的排列方向）。它的取值有：<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
</li>
<li>flex-wrap属性：默认情况下，项目都排在一条线（轴线）上。flex-wrap 属性定义如果一条轴线排不下，如何换行。它的取值有：<ul>
<li>nowrap（默认）：不换行。</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ul>
</li>
<li>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</li>
<li>justify-content 属性定义了项目在主轴上的对齐方式。它的取值有：<ul>
<li>flex-start：使所有 flex 项都位于主轴的开始处。</li>
<li>flex-end：使所有 flex 项到主轴的结尾处。</li>
<li>center：使 flex 项在主轴居中。</li>
<li>space-between：使 flex 项两端对齐，项目之间的间隔都相等。</li>
<li>space-around：使每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</li>
<li>align-items 属性定义项目在交叉轴上如何对齐。它可能取5个值，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下：<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li>
</ul>
</li>
<li>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。它的可能取值为：<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
</li>
</ul>
<h5 id="项目的属性："><a href="#项目的属性：" class="headerlink" title="项目的属性："></a>项目的属性：</h5><ul>
<li>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</li>
<li>flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</li>
<li>flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</li>
<li>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。它可以设为跟 width 或 height 属性一样的值（比如 350 px），则项目将占据固定空间。</li>
<li>flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</li>
<li>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。</li>
</ul>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li><p>background-image 还有一组可用的值：颜色渐变。通过 linear-gradient() 函数设置，函数至少需要用逗号分隔的三个参数——背景中渐变的方向，开始的颜色和结尾的颜色。例如：</p>
</li>
<li><style>
  .box{
            width: 100px;
            height: 100px;
            background-image:     linear-gradient(to bottom, red, blue);
            }
</style>


</li>
</ul>
<h4 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h4><ul>
<li>outline-color 设置轮廓的颜色。取值和其余颜色的取值一样。</li>
<li>outline-style 设置轮廓的样式。取值如下：</li>
</ul>
<ul>
<li>outline-width 设置轮廓的宽度。它的值有：<ul>
<li>thin 规定细轮廓。</li>
<li>medium 默认取值规定中等的轮廓。</li>
<li>thick 规定粗的轮廓。</li>
<li>length 允许你自定义轮廓粗细的值。</li>
<li>inherit 规定应该从父元素继承轮廓宽度的设置。</li>
</ul>
</li>
<li>outline 上面三个属性的连写。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">      <span class="selector-tag">p</span> &#123;</span><br><span class="line">          <span class="attribute">outline</span>: red dotted thick;</span><br><span class="line">          <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h4 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h4><p>box-shadow 属性设置盒子阴影。box-shadow 有四个值:</p>
<ul>
<li><p>第一个值是水平偏移量（水平阴影）：即向右的距离，阴影被从原始的框中偏移(如果值为负的话则为左)。</p>
</li>
<li><p>第二个值是垂直偏移量（垂直阴影）：即阴影从原始盒子中向下偏移的距离(或向上，如果值为负)。</p>
</li>
<li><p>第三个值是模糊半径（影子大小）：即在阴影中应用的模糊度。</p>
</li>
<li><p>第四个值是阴影的基本颜色。你可以使用任何长度和颜色单位来定义这些值。</p>
<p>box-shadow: 5px 5px 5px red;</p>
</li>
</ul>
<p>使用 inset 关键字，把它放在一个影子声明的开始，使它变成一个内部阴影，而不是一个外部阴影。</p>
<p> box-shadow: inset 5px 5px 5px red;</p>
<h4 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h4><ul>
<li>基础选择器：标签选择器，类选择器，ID 选择器，通配符选择器</li>
<li>组合选择器：标签指定式选择器，后代选择器，并集选择器</li>
<li>属性选择器</li>
<li>伪类选择器</li>
</ul>
<h4 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h4><ul>
<li>优先级：<ul>
<li>规则（1）：行内样式 &gt; 页内样式 &gt; 外部引用样式 &gt; 浏览器默认样式。</li>
<li>规则（2）：important &gt; 内联 &gt; ID &gt; 伪类|类 | 属性选择 &gt; 标签 &gt; 伪对象 &gt; 通配符 &gt; 继承。另外权重会叠加，所以为了便于理解，权重设置如下：<ul>
<li>1 表示标签选择器的权重</li>
<li>10 表示类选择器的权重</li>
<li>100 表示 ID 选择器的权重</li>
<li>1000 表示内联样式的权重</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注：权重相同时，CSS 遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。所有都相同时，声明靠后的优先级大。</p>
<h4 id="CSS-排版"><a href="#CSS-排版" class="headerlink" title="CSS 排版"></a>CSS 排版</h4><h5 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>：<span class="selector-tag">static</span>;</span><br></pre></td></tr></table></figure>

<p>静态定位是每个元素获取的默认值，所以我们基本上都不需要再单独设置它</p>
<h5 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>：<span class="selector-tag">absolute</span>;</span><br></pre></td></tr></table></figure>

<p>绝对定位有以下特点：</p>
<ul>
<li>绝对定位以浏览器左上角为基准设置位置</li>
<li>当一个盒子包含在另一个盒子中，父盒子未设置定位，子盒子以浏览器左上角为基准设置位置； 当父盒子设置定位，子盒子以父盒子左上角为基准设置位置</li>
<li>绝对定位不占空间位置（类似于浮动）</li>
</ul>
<h5 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>：<span class="selector-tag">relative</span>;</span><br></pre></td></tr></table></figure>

<p>相对定位有以下特点：</p>
<ul>
<li>相对定位以元素自身的位置为基准设置位置</li>
<li>相对定位要占空间位置</li>
<li>一般子元素设置绝对定位，父元素设置相对定位（子绝父相）</li>
</ul>
<h5 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h5><p>固定定位表现类似于绝对定位，只有一个主要区别：绝对定位固定元素是相对于 <html> 元素或其最近的定位祖先，而固定定位固定元素则是相对于浏览器视口本身。固定定位也不占空间位置，语法为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>：<span class="selector-tag">fixed</span>;</span><br></pre></td></tr></table></figure>

<h5 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h5><p>z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。用于处理当多个元素重叠的时候，哪些元素设置在其他元素的顶部。特别需要注意的是元素可拥有负的 z-index 属性值，属性值没有单位，只有数字。Z-index 仅能在定位元素上奏效（例如 position:absolute;）</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%9D%E7%BB%B4-%E5%8D%A1%E5%86%85%E5%9F%BA%E6%A2%85%E9%9A%86%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E4%B8%BB%E4%BB%BB%E5%91%A8%E4%BB%A5%E7%9C%9F%EF%BC%88%E8%8B%B1%E6%B1%89%E5%AF%B9%E7%85%A7%E7%89%88%EF%BC%89/">计算机思维-卡内基梅隆大学计算机系主任周以真（英汉对照版）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/CSAPP/">CSAPP</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%9D%E7%BB%B4/">计算机思维</a></span><div class="content"><p><a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/afs/cs/usr/wing/www/publications/Wing06.pdf">英文版CACM</a><br>Jeannette M. Wing (周以真)<br>(翻译：徐韵文，王飞跃, 校对：王飞跃） </p>
<h2 id="Computational-Thinking"><a href="#Computational-Thinking" class="headerlink" title="Computational Thinking"></a>Computational Thinking</h2><p>It represents a universally applicable attitude and skill set everyone, not just computer scientists, would be eager to learn and use.</p>
<p>它代表着一种普遍的认识和一类普适的技能，每一个人，不仅仅是计算机科学家，都应热心于它的学习和运用。 </p>
<p>Computational thinking builds on the power and limits of computing processes, whether they are executed by a human or by a machine. Computational methods and models give us the courage to solve problems and design systems that no one of us would be capable of tackling alone. Computational thinking confronts the riddle of machine intelligence: What can humans do better than computers? and What can computers do better than humans? Most fundamentally it addresses the question: What is computable? Today, we know only parts of the answers to such questions.</p>
<p>计算思维是建立在计算过程的能力和限制之上的，不管这些过程是由人还是由机器执行的。计算方法和模型给了我们勇气去处理那些原本无法由任何个人独自完成的问题求解和系统设计。计算思维直面机器智能的不解之谜：什么人类能比计算机做得更好？什么计算机能比人类做得更好？最基本的是它涉及这样的问题：什么是可计算的？今天，我们对这些问题的答案仍是一知半解。 </p>
<p>Computational thinking is a fundamental skill for everyone, not just for computer scientists. To reading, writing, and arithmetic, we should add computational thinking to every child’s analytical ability. Just as the printing press facilitated the spread of the three Rs, what is appropriately incestuous about this vision is that computing and computers facilitate the spread of computational thinking.</p>
<p>计算思维是每个人的基本技能，不仅仅属于计算机科学家。在阅读、写作和算术（英文简称3R）之外，我们应当将计算思维加到每个孩子的解析能力之中。正如印刷出版促进了3R的传播，计算和计算机也以类似的正反馈促进了计算思维的传播。 </p>
<p>Computational thinking involves solving problems, designing systems, and understanding human behavior, by drawing on the concepts fundamental to computer science. Computational thinking includes a range of mental tools that reflect the breadth of the field of computer science.</p>
<p>计算思维涉及运用计算机科学的基础概念去求解问题、设计系统和理解人类的行为。计算思维涵盖了反映计算机科学之广泛性的一系列思维活动。 </p>
<p>Having to solve a particular problem, we might ask: How difficult is it to solve? and What’s the best way to solve it? Computer science rests on solid theoretical underpinnings to answer such questions precisely. Stating the difficulty of a problem accounts for the underlying power of the machine—the computing device that will run the solution. We must consider the machine’s instruction set, its resource constraints, and its operating environment.</p>
<p>当求解一个特定的问题时，我们会问：解决这个问题有多困难？怎样才是最佳的解决之道? 计算机科学根据坚实的理论基础来准确地回答这些问题。表明问题的困难程度是为了考量机器——就是用来运行其解的计算工具之基本能力。我们必须考虑机器的指令系统、它的资源约束和它的操作环境。 </p>
<p>In solving a problem efficiently, we might further ask whether an approximate solution is good enough, whether we can use randomization to our advantage, and whether false positives or false negatives are allowed. Computational thinking is reformulating a seemingly difficult problem into one we know how to solve, perhaps by reduction, embedding, transformation, or simulation.</p>
<p>为了有效地求解一个问题，我们可能要进一步问：一个近似解是否就足够了，是否可以利用一下随机化，以及是否允许误正或误负。计算思维就是把一个看来困难的问题重新阐述成一个我们知道怎样解的问题，如通过约简、嵌入、转化和仿真的方法。 </p>
<p>Computational thinking is thinking recursively. It is parallel processing. It is interpreting code as data and data as code. It is type checking as the generalization of dimensional analysis. It is recognizing both the virtues and the dangers of aliasing, or giving someone or something more than one name. It is recognizing both the cost and power of indirect addressing and procedure call. It is judging a program not just for correctness and efficiency but for aesthetics, and a system’s design for simplicity and elegance.</p>
<p>计算思维是一种递归思维。它是并行处理。它是把代码译成数据又把数据译成代码。它是由推广量纲分析进行的类型检查。对于别名或赋予人与物多个名字的做法，它既知道其益处又了解其害处。对于间接寻址和程序调用的做法，它既知道其威力又了解其代价。它评价一个程序时，不仅仅根据其准确性和效率，还有美学的考量，而对于系统的设计，还考虑简洁和优雅。 </p>
<p>Computational thinking is using abstraction and decomposition when attacking a large complex task or designing a large complex system. It is separation of concerns. It is choosing an appropriate representation for a problem or modeling the relevant aspects of a problem to make it tractable. It is using invariants to describe a system’s behavior succinctly and declaratively. It is having the confidence we can safely use, modify, and influence a large complex system without understanding its every detail. It is modularizing something in anticipation of multiple users or prefetching and caching in anticipation of future use.</p>
<p>计算思维采用了抽象和分解来迎战浩大复杂的任务或者设计巨大复杂的系统。它是关注的分离。它是选择合适的方式去陈述一个问题，或者是选择合适的方式对一个问题的相关方面建模使其易于处理。它是利用不变量简明扼要且表述性地刻画系统的行为。它是我们在不必理解每一个细节的情况下就能够安全地使用、调整和影响一个大型复杂系统的信心。它就是为预期的多个用户而进行的模块化，它就是为预期的未来应用而进行的预置和缓存。 </p>
<p>Computational thinking is thinking in terms of prevention, protection, and recovery from worst-case scenarios through redundancy, damage containment, and error correction. It is calling gridlock deadlock and contracts interfaces. It is learning to avoid race conditions when synchronizing meetings with one another.</p>
<p>计算思维是通过冗余、堵错、纠错的方式，在最坏情况下进行预防、保护和恢复的一种思维。它称堵塞为死结，叫合同为界面。它就是学习在谐调同步相互会合时如何避免竞争的情形。 </p>
<p>Computational thinking is using heuristic reasoning to discover a solution. It is planning, learning, and scheduling in the presence of uncertainty. It is search, search, and more search, resulting in a list of Web pages, a strategy for winning a game, or a counterexample. Computational thinking is using massive amounts of data to speed up computation. It is making trade-offs between time and space and between processing power and storage capacity.</p>
<p>计算思维是利用启发式推理来寻求解答。它就是在不确定情况下的规划、学习和调度。它就是搜索、搜索、再搜索，最后得到的是一系列的网页，一个赢得游戏的策略，或者一个反例。计算思维是利用海量的数据来加快计算。它就是在时间和空间之间，在处理能力和存储容量之间的权衡。 </p>
<p>Consider these everyday examples: When your daughter goes to school in the morning, she puts in her backpack the things she needs for the day; that’s prefetching and caching. When your son loses his mittens, you suggest he retrace his steps; that’s backtracking. At what point do you stop renting skis and buy yourself a pair?; that’s online algorithms. Which line do you stand in at the supermarket?; that’s performance modeling for multi-server systems. Why does your telephone still work during a power outage?; that’s independence of failure and redundancy in design. How do Completely Automated Public Turing Test(s) to Tell Computers and Humans Apart, or CAPTCHAs, authenticate humans?; that’s exploiting the difficulty of solving hard AI problems to foil computing agents.</p>
<p>考虑这些日常中的事例：当你女儿早晨去学校时，她把当天需要的东西放进背包；这就是预置和缓存。当你儿子弄丢他的手套时，你建议他沿走过的路回寻；这就是回推。在什么时候你停止租用滑雪板而为自己买一对呢？这就是在线算法。在超市付账时你应当去排哪个队呢？这就是多服务器系统的性能模型。为什么停电时你的电话仍然可用？这就是失败的无关性和设计的冗余性。完全自动的大众图灵测试是如何区分计算机和人类（简称CAPTCHA）的，即CAPTCHAs是怎样鉴别人类的？这就是充分利用求解人工智能难题之艰难来挫败计算代理程序。 </p>
<p>Computational thinking will have become ingrained in everyone’s lives when words like algorithm and precondition are part of everyone’s vocabulary; when nondeterminism and garbage collection take on the meanings used by computer scientists; and when trees are drawn upside down.</p>
<p>计算思维将渗入到我们每个人的生活之中，那时诸如算法和前提条件已成为每个人日常词汇的一部分，非确定论和垃圾收集已含有计算机学家所指的含义，而树已常常被倒过来画了。 </p>
<p>Thinking like a computer scientist means more than being able to program a computer. It requires thinking at multiple levels of abstraction.</p>
<p>像计算机科学家一样思考意味着不仅仅能够计算机编程。 它需要在多个抽象层面上进行思考。</p>
<p>We have witnessed the influence of computational thinking on other disciplines. For example, machine learning has transformed statistics. Statistical learning is being used for problems on a scale, in terms of both data size and dimension, unimaginable only a few years ago. Statistics departments in all kinds of organizations are hiring computer scientists. Schools of computer science are embracing existing or starting up new statistics departments.</p>
<p>我们已见证了计算思维在其它学科中的影响。例如，机器学习已经改变了统计学。就数据尺度和维数而言，统计学习用于各类问题的规模仅在几年前还是不可想象的。各种组织的统计部门都聘请了计算机科学家。计算机学院系正在联姻已有或开设新的统计部门。 </p>
<p>Computer scientists’ recent interest in biology is driven by their belief that biologists can benefit from computational thinking. Computer science’s contribution to biology goes beyond the ability to search through vast amounts of sequence data looking for patterns. The hope is that data structures and algorithms—our computational abstractions and methods—can represent the structure of proteins in ways that elucidate their function. Computational biology is changing the way biologists think. Similarly, computational game theory is changing the way economists think; nanocomputing, the way chemists think; and quantum computing, the way physicists think.</p>
<p>计算机学家们近来对生物科学的兴趣是由他们坚信生物学家能够从计算思维中获益的信念驱动的。计算机科学对于生物学的贡献决不限于其能够在海量时序数据中搜索寻找模式规律的本领。最终的希望是数据结构和算法——我们的计算抽象和方法——能够以阐释其功能的方式表示蛋白质的结构。计算生物学正在改变着生物学家的思考方式。类似地，计算博弈理论正改变着经济学家的思考方式，纳米计算改变着化学家的思考方式，量子计算改变着物理学家的思考方式。 </p>
<p>This kind of thinking will be part of the skill set of not only other scientists but of everyone else. Ubiquitous computing is to today as computational thinking is to tomorrow. Ubiquitous computing was yesterday’s dream that became today’s reality; computational thinking is tomorrow’s reality.</p>
<p>这种思维将成为不仅仅是其他科学家，而且是其他每一个人的技能组合之部分。普在计算之于今天就是计算思维之于明天。普在计算是已变为今日之现实的昨日之梦，计算思维就是明日之现实。 </p>
<p>WHAT IT IS, AND ISN’T</p>
<p>它是什么，又不是什么 </p>
<p>Computer science is the study of computation— what can be computed and how to compute it. Computational thinking thus has the following characteristics:</p>
<p>计算机科学是计算的学问——什么是可计算的，怎样去计算。因此，计算思维具有以下特性： </p>
<p>Conceptualizing, not programming. Computer science is not computer programming. Thinking like a computer scientist means more than being able to program a computer. It requires thinking at multiple levels of abstraction;</p>
<p>概念化，不是程序化。计算机科学不是计算机编程。像计算机科学家那样去思维意味着远远不止能为计算机编程。它要求能够在抽象的多个层次上思维。 </p>
<p>Fundamental, not rote skill. A fundamental skill is something every human being must know to function in modern society. Rote means a mechanical routine. Ironically, not until computer science solves the AI Grand Challenge of making computers think like humans will thinking be rote;</p>
<p>基础的，不是机械的技能。基础的技能是每一个人为了在现代社会中发挥职能所必须掌握的。生搬硬套之机械的技能意味着机械的重复。具有讽刺意味的是，只有当计算机科学解决了人工智能的宏伟挑战——使计算机像人类一样思考之后，思维才会变成机械的生搬硬套。 </p>
<p>A way that humans, not computers, think. Computational thinking is a way humans solve problems; it is not trying to get humans to think like computers. Computers are dull and boring; humans are clever and imaginative. We humans make computers exciting. Equipped with computing devices, we use our cleverness to tackle problems we would not dare take on before the age of computing and build systems with functionality limited only by our imaginations;</p>
<p>人的，不是计算机的思维。计算思维是人类求解问题的一条途径，但决非试图使人类像计算机那样地思考。计算机枯燥且沉闷；人类聪颖且富有想象力。我们人类赋予计算机以激情。配置了计算设备，我们就能用自己的智慧去解决那些计算时代之前不敢尝试的问题，就能建造那些其功能仅仅受制于我们想象力的系统。 </p>
<p>Complements and combines mathematical and engineering thinking. Computer science inherently draws on mathematical thinking, given that, like all sciences, its formal foundations rest on mathematics. Computer science inherently draws on engineering thinking, given that we build systems that interact with the real world. The constraints of the underlying computing device force computer scientists to think computationally, not just mathematically. Being free to build virtual worlds enables us to engineer systems beyond the physical world;</p>
<p>数学和工程思维的互补与融合。计算机科学在本质上源自数学思维，因为像所有的科学一样，它的形式化解析基础筑于数学之上。计算机科学又从本质上源自工程思维，因为我们建造的是能够与实际世界互动的系统。基本计算设备的限制迫使计算机学家必须计算性地思考，不能只是数学性地思考。构建虚拟世界的自由使我们能够超越物理世界去打造各种系统。 </p>
<p>Ideas, not artifacts. It’s not just the software and hardware artifacts we produce that will be physically present everywhere and touch our lives all the time, it will be the computational concepts we use to approach and solve problems, manage our daily lives, and communicate and interact with other people; and</p>
<p>是思想，不是人造品。不只是我们生产的软件硬件人造品将以物理形式到处呈现并时时刻刻触及我们的生活，更重要的是还将有我们用以接近和求解问题、管理日常生活、与他人交流和互动之计算性的概念；而且， </p>
<p>For everyone, everywhere. Computational thinking will be a reality when it is so integral to human endeavors it disappears as an explicit philosophy.</p>
<p>面向所有的人，所有地方。当计算思维真正融入人类活动的整体以致不再是一种显式之哲学的时候，它就将成为现实。 </p>
<p>Many people equate computer science with computer programming. Some parents see only a narrow range of job opportunities for their children who major in computer science. Many people think the fundamental research in computer science is done and that only the engineering remains. Computational thinking is a grand vision to guide computer science educators, researchers, and practitioners as we act to change society’s image of the field. We especially need to reach the pre-college audience, including teachers, parents, and students, sending them two main messages:</p>
<p>许多人将计算机科学等同于计算机编程。有些家长为他们主修计算机科学的孩子看到的只是一个狭窄的就业范围。许多人认为计算机科学的基础研究已经完成，剩下的只是工程部分而已。当我们行动起来去改变这一领域的社会形象时，计算思维就是一个引导着计算机教育家、研究者和实践者的宏大愿景。我们特别需要走进大学之前的听众，包括老师、父母、学生，向他们传送两个主要信息： </p>
<p>Intellectually challenging and engaging scientific problems remain to be understood and solved. The problem domain and solution domain are limited only by our own curiosity and creativity; and</p>
<p>智力上极有挑战性并且引人入胜的科学问题依旧亟待理解和解决。这些问题的范围和解决方案的范围之唯一局限就是我们自己的好奇心和创造力；同时 </p>
<p>One can major in computer science and do anything. One can major in English or mathematics and go on to a multitude of different careers. Ditto computer science. One can major in computer science and go on to a career in medicine, law, business, politics, any type of science or engineering, and even the arts.</p>
<p>一个人可以主修计算机科学并且干什么都行。一个人可以主修英语或者数学，接着从事各种各样的职业。计算机科学也一样。一个人可以主修计算机科学，接着从事医学、法律、商业、政治，以及任何类型的科学和工程，甚至艺术工作。 </p>
<p>Professors of computer science should teach a course called “Ways to Think Like a Computer Scientist” to college freshmen, making it available to non-majors, not just to computer science majors. We should expose pre-college students to computational methods and models. Rather than bemoan the decline of interest in computer science or the decline in funding for research in computer science, we should look to inspire the public’s interest in the intellectual adventure of the field. We’ll thus spread the joy, awe, and power of computer science, aiming to make computational thinking commonplace.</p>
<p>计算机科学的教授应当为大学新生开一门称为“怎么像计算机科学家一样思维”的课，面向非专业的，而不仅仅是计算机科学专业的学生。我们应当使大学之前的学生接触计算的方法和模型。我们应当设法激发公众对于计算机领域中的科学探索之兴趣，而不是悲叹对其兴趣的衰落或者哀泣其研究经费的下降。所以，我们应当传播计算机科学的快乐、崇高和力量，致力于计算思维的常识化。</p>
<p>本文引用地址：<a target="_blank" rel="noopener" href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=2374&amp;do=blog&amp;id=8104">http://blog.sciencenet.cn/home.php?mod=space&amp;uid=2374&amp;do=blog&amp;id=8104</a> </p>
<p>相关文章:从计算思维到计算文化:<a target="_blank" rel="noopener" href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=2374&amp;do=blog&amp;id=8105">http://blog.sciencenet.cn/home.php?mod=space&amp;uid=2374&amp;do=blog&amp;id=8105</a></p>
<p>蒲定东补：</p>
<p>周以真在文中提及</p>
<p>Computational thinking is reformulating a seemingly difficult problem into one we know how to solve, perhaps by reduction, embedding, transformation, or simulation.</p>
<p>计算思维就是把一个看来困难的问题重新阐述成一个我们知道怎样解的问题，如通过约简、嵌入、转化和仿真的方法。 </p>
<p>计算思维：解构、模式识别、模式归纳（抽象）、算法设计；<br>抽象思维：破解、离散、变换、拟合；<br>信息工程思维：数据化、建模、计算、仿真；<br>诗格：起、承、转、合；<br>修辞格：隐喻、反讽、转喻、提喻；<br>古希腊哲人爱比克泰德的哲思：物是，如其然；物已非，其惘然；物既非，不然其然；物复是，如其未然；<br>《周易》占卜：元、亨、利、贞；</p>
<p>本文发表于2007年第3卷第11期的中国计算机学会通讯。 </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E6%A5%BC/">操作系统-实验楼</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/">实验楼</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><div class="content"><h2 id="实验楼-（一）熟悉实验环境"><a href="#实验楼-（一）熟悉实验环境" class="headerlink" title="实验楼  （一）熟悉实验环境"></a>实验楼  （一）熟悉实验环境</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><ul>
<li>cd /home/shiyanlou/oslab/    进入 oslab 所在文件夹 </li>
<li>tar -zxvf hit-oslab-linux-20110823.tar.gz -C /home/shiyanlou/  解压到指定文件夹<br>-ls -al 查看解压是否成功</li>
</ul>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul>
<li>Image<ul>
<li>宿主系统编译之后的目标文件</li>
</ul>
</li>
<li>bochs</li>
<li>run (运行bochs的脚本)</li>
<li>hdc-0.11.img<ul>
<li>Bash shell</li>
<li>basic linux orders  .   cp rm mv tar…</li>
<li>vi 编辑器</li>
<li>gcc 1.4编译器</li>
<li>as86 and ld86</li>
<li>linux 源代码</li>
</ul>
</li>
</ul>
<h3 id="准备编译"><a href="#准备编译" class="headerlink" title="准备编译"></a>准备编译</h3><ul>
<li>pwd   确认当前目录位于oslab</li>
<li>ls -l   列出目录内容</li>
</ul>
<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><ul>
<li><p>开始</p>
<ul>
<li>cd ./linux-0.11/</li>
<li>make all   (make -j 2)  || make clean &amp;&amp; make all</li>
<li>关闭 run 窗口</li>
</ul>
</li>
<li><p>运行</p>
<ul>
<li>cd ~/oslab/</li>
<li>./run  =&gt; [/user/root]#</li>
</ul>
</li>
<li><p>调试</p>
<ul>
<li>汇编级调试</li>
<li>cd ~/oslab/</li>
<li>./dbg-asm =&gt; 黑屏</li>
<li>C 语言级调试</li>
<li>cd ~/oslab</li>
<li>./dbg-c</li>
<li>再打开一个终端接口</li>
<li>cd ~/oslab/<br>-./rungdb</li>
</ul>
</li>
<li><p>文件交换</p>
<ul>
<li><p>cd ~/oslab/</p>
</li>
<li><p>sudo ./mount-hdc 启动挂载脚本 （可以在 Ubuntu 的 hdc 目录下创建一个 xxx.c 文件，然后用编辑器编辑器）</p>
</li>
<li><p>cd ~/oslab/hdc  进入挂载到hdc的目录</p>
</li>
<li><p>ls -al 查看内容</p>
</li>
<li><p>cd ~/oslab/</p>
</li>
<li><p>sudo umount hdc 卸载文件系统 （执行后再进入 linux0.11，会看到上述 xxx.c 文件）</p>
</li>
</ul>
</li>
</ul>
<h2 id="实验二-操作系统的引导"><a href="#实验二-操作系统的引导" class="headerlink" title="实验二 操作系统的引导"></a>实验二 操作系统的引导</h2><h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><ul>
<li><p>进入  ~/oslab/linux-0.11/boot/</p>
</li>
<li><p>bootsect.s </p>
<p>as86 -0 -a -o bootsect.o bootsect.s<br>​ld86 -0 -s -o bootsect bootsect.o</p>
</li>
</ul>
<h4 id="五种存储器寻址方式。"><a href="#五种存储器寻址方式。" class="headerlink" title="五种存储器寻址方式。"></a>五种存储器寻址方式。</h4><ul>
<li>立即寻址方式(Immediate addressing)</li>
<li>寄存器寻址方式(Register addressing)</li>
<li>直接寻址方式(Direct addressing)</li>
<li>寄存器间接寻址方式(Register indirect addressing)</li>
<li>寄存器相对寻址方式(Register relative addressing)</li>
<li>基址变址寻址方式(Based indexed addressing)</li>
<li>相对基址变址寻址方式(Relative based indexed addressing)</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/06/07/HTML%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C%E6%A5%BC/">HTML基础-实验楼</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/">实验楼</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/HTML/">HTML</a></span><div class="content"><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP/1.1 定义的请求方法有 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。最常的两种是 GET 和 POST，如果是 RESTful 接口的话一般会用到 GET、POST、DELETE、PUT。</p>
<h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><ul>
<li>200 ：成功。</li>
<li>400 ：客户端请求有语法错误，服务器端不能理解。</li>
<li>401 ：该请求可能未经过授权。</li>
<li>403 ：服务器端收到该请求，但是拒绝为它提供服务，可能是没有权限等等。</li>
<li>404 ：该资源没找到。</li>
<li>500 ：服务器端发生了一个不可预知的错误。</li>
<li>503 ：服务器端当前还不能处理客户端的这个请求，可能过段时间之后才能恢复正常。</li>
</ul>
<h4 id="浏览器的访问过程具体是什么呢？"><a href="#浏览器的访问过程具体是什么呢？" class="headerlink" title="浏览器的访问过程具体是什么呢？"></a>浏览器的访问过程具体是什么呢？</h4><ol>
<li>首先浏览器请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP。</li>
<li>通过 IP 与目的主机建立 TCP 连接。</li>
<li>发送和接受数据（获取网页内容）。</li>
<li>断开 TCP 连接。</li>
</ol>
<h4 id="文件的上传与下载到底是怎么回事？-前端的各种处理方式："><a href="#文件的上传与下载到底是怎么回事？-前端的各种处理方式：" class="headerlink" title="文件的上传与下载到底是怎么回事？ 前端的各种处理方式："></a>文件的上传与下载到底是怎么回事？ 前端的各种处理方式：</h4><ul>
<li>传统 flash 上传</li>
<li>新增 iframe 框 ajax 上传</li>
<li>表单数据提交</li>
<li>HTML5 的新工具——File API</li>
</ul>
<h4 id="iframe-框-Ajax-上传和表单数据提交："><a href="#iframe-框-Ajax-上传和表单数据提交：" class="headerlink" title="iframe 框 Ajax 上传和表单数据提交："></a>iframe 框 Ajax 上传和表单数据提交：</h4><ul>
<li>iframe 框上传：通过新建一个隐藏的 iframe 框，把数据放到这个 iframe 框架里，然后把它提交到服务器端处理，服务器返回的信息也是由 iframe 框调用父框架的方法处理。</li>
<li>表单数据提交：重点有两个，一个是 FormData 的数据对象，一个是 level2 的 XMLHttpRequest 对象。</li>
</ul>
<h4 id="有序列表（ol）"><a href="#有序列表（ol）" class="headerlink" title="有序列表（ol）"></a>有序列表（ol）</h4><p>定义：有序列表是一列项目，列表项目使用数字进行标记。有序列表始于<ol> 标签。每个列表项始于 <li> 标签。</p>
<ul>
<li>有序列表有 type 和 start 属性。</li>
<li>语法格式：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">value1</span> <span class="attr">start</span>=<span class="string">value2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：value1 表示有序列表项目符号的类型, value2 表示项目开始的数值。</p>
<table>
<thead>
<tr>
<th>type类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type=1</td>
<td>表示列表项目用数字表示（1，2，3…)</td>
</tr>
<tr>
<td>type=a</td>
<td>表示列表项目用小写字母表示（a,b,c…)</td>
</tr>
<tr>
<td>type=A</td>
<td>表示列表项目用大写字母表示（A,B,C…)</td>
</tr>
<tr>
<td>type=i</td>
<td>表示列表项目用小写罗马数字表示(i,ii,iii….)</td>
</tr>
<tr>
<td>type=I</td>
<td>表示列表项目用大写罗马数字表示(I,II,III…)</td>
</tr>
</tbody></table>
<h4 id="自定义列表（dl）"><a href="#自定义列表（dl）" class="headerlink" title="自定义列表（dl）"></a>自定义列表（dl）</h4><p>定义：自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以<dl> 标签开始。每个自定义列表项以 <dt> 开始。每个自定义列表项的定义以 <dd> 开始。自定义列表的列表项前没有任何项目符号。</p>
<p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="HTML-元数据"><a href="#HTML-元数据" class="headerlink" title="HTML 元数据"></a>HTML 元数据</h4><meta>标签提供关于 HTML 文档的元数据：描述（description）、关键词（keywords）、文档的作者（author）等其他元数据。



<h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><ul>
<li>标题：header</li>
<li>导航栏：nav</li>
<li>主要内容：main 具有代表性的内容段落主题可以使用 article   section，div元素。</li>
<li>侧栏：aside经常嵌套在main中</li>
<li>页脚：footer</li>
</ul>
<h4 id="表单基本标签"><a href="#表单基本标签" class="headerlink" title="表单基本标签"></a>表单基本标签</h4><p>表格的其他常用属性：</p>
<p>colspan  合并行</p>
<p>rowspan 和并列</p>
<p>caption 定义标题</p>
<ul>
<li><p>thead：用于定义表格的头部，一般包含网页的logo和导航等头部信息,位于table之中。</p>
</li>
<li><p>tfoot：用于定义表格的页脚，一般包含网页底部的企业信息，地址联系方式等，位于table标记之中，thead标记之后。</p>
</li>
<li><p>tbody：用于定义表格的主体，一般包含网页中除头部和底部之外的其他内容，位于table标记之中，tfoot标记之后。</p>
<h5 id="注：案例-：搜狐股票"><a href="#注：案例-：搜狐股票" class="headerlink" title="注：案例 ：搜狐股票"></a>注：案例 ：搜狐股票</h5></li>
</ul>
<h4 id="多媒体嵌入"><a href="#多媒体嵌入" class="headerlink" title="多媒体嵌入"></a>多媒体嵌入</h4><ul>
<li><p>video </p>
</li>
<li><p>audio </p>
</li>
<li><p>音频播放器所占用的空间比视频播放器要小，由于没有视觉部件，只需要显示出能控制音频播放的控件。它不支持 width/height 属性。</p>
</li>
<li><p>iframe </p>
</li>
</ul>
<h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p>表单在网页中主要负责数据采集功能。一个表单有三个基本组成部分：</p>
<ul>
<li>表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL 以及数据提交到服务器的方法。</li>
<li>表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。</li>
<li>表单按钮：包括提交按钮、复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。</li>
</ul>
<p>fieldset 元素组合表单中的相关数据，legend 元素为 fieldset元素定义标题。</p>
<p>label 标签的 for 属性应当与相关元素的 id 属性相同，使得label 标签与 input 正确相关联。</p>
<p>原生表单组件，主要包含文本输入框、单行文本框、e-mail 输入框、密码输入框、搜索框、电话号码输入框、URL 输入框、多行文本框、下拉组件、可勾选组件、按钮。</p>
<h4 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h4><p>所有文本域的通用规范：</p>
<ul>
<li><p>它们可以被标记为 readonly (用户不能修改输入值)甚至是 disabled (输入值永远不会与表单数据的其余部分一起发送)。</p>
</li>
<li><p>它们可以有一个 placeholder; 这是文本输入框中出现的文本，用来简略描述输入框的目的。</p>
</li>
<li><p>它们都受 size (输入框的物理尺寸) 和 length (文本框可以输入的最大字符数)约束。</p>
</li>
<li><p>如果浏览器支持的话，可以进行拼写检查。</p>
<p>文本区域在右下角有一个拖放操作，允许用户调整它的大小。这种调整能力可以通过使用 CSS 设置文本区域的 resize 值为 none 来关闭。</p>
</li>
</ul>
<h4 id="下拉组件"><a href="#下拉组件" class="headerlink" title="下拉组件"></a>下拉组件</h4><p>自动补全组件:</p>
<p> 使用 datalist 元素来为表单小部件提供建议 的、自动完成的值，并使用一些 option 子元素来指定要显示的值。然后使用 list 属性将数据列表绑定到一个文本域(通常是一个 input元素)。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 By Gloria</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>